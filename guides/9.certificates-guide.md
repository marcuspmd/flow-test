# Guia de Certificados Digitais

## Visão Geral

O Flow Test Engine suporta autenticação com certificados digitais para requisições HTTPS (mTLS - mutual TLS). Este guia cobre tudo que você precisa saber para configurar e usar certificados em seus testes.

## Formatos Suportados

### 1. PEM (Privacy Enhanced Mail)
- Formato baseado em texto (Base64)
- Certificado e chave em arquivos **separados**
- Extensões comuns: `.crt`, `.pem`, `.key`
- Mais comum em ambientes Unix/Linux

**Exemplo:**
```yaml
certificate:
  cert_path: "./certs/client.crt"
  key_path: "./certs/client.key"
  passphrase: "{{$env.CERT_PASSWORD}}"  # Opcional
  ca_path: "./certs/ca.crt"             # Opcional
```

### 2. PFX/P12 (Personal Information Exchange)
- Formato binário
- Certificado e chave em um **único arquivo**
- Extensões: `.pfx`, `.p12`
- Mais comum em ambientes Windows

**Exemplo:**
```yaml
certificate:
  pfx_path: "./certs/certificate.pfx"
  passphrase: "{{$env.PFX_PASSWORD}}"
  ca_path: "./certs/ca.crt"  # Opcional
```

## Níveis de Configuração

### 1. Global (flow-test.config.yml)

Certificados globais aplicam-se a todas as requisições, com filtros opcionais por domínio:

```yaml
globals:
  base_url: "https://api.example.com"

  certificates:
    # Certificado para APIs corporativas
    - name: "Corporate API Certificate"
      cert_path: "./certs/corporate.crt"
      key_path: "./certs/corporate.key"
      passphrase: "{{$env.CORPORATE_CERT_PASS}}"
      domains: ["*.company.com", "*.empresa.com.br"]
      min_version: "TLSv1.2"  # Forçar TLS 1.2 ou superior
      max_version: "TLSv1.3"  # Limitar até TLS 1.3

    # Certificado para APIs governamentais
    - name: "Gov API Certificate"
      pfx_path: "./certs/gov-cert.pfx"
      passphrase: "{{$env.GOV_CERT_PASS}}"
      domains: ["*.gov.br", "*.receita.fazenda.gov.br"]

    # Certificado sem restrição de domínio (aplica a todos)
    - name: "Fallback Certificate"
      cert_path: "./certs/fallback.crt"
      key_path: "./certs/fallback.key"
```

### 2. Suite Level (tests/suite.yaml)

Certificado específico para toda a suite, sobrescreve certificados globais:

```yaml
suite_name: "Secure API Tests"
node_id: "secure-api"
base_url: "https://secure-api.example.com"

certificate:
  cert_path: "./certs/test-client.crt"
  key_path: "./certs/test-client.key"
  passphrase: "{{test_cert_password}}"
  min_version: "TLSv1.2"  # Mínimo TLS 1.2

steps:
  - name: "Test protected endpoint"
    request:
      method: GET
      url: "/protected/resource"
```

### 3. Step Level

Certificado específico para um único step, maior prioridade:

```yaml
steps:
  - name: "Admin operation with special certificate"
    request:
      method: POST
      url: "/admin/action"
      certificate:
        pfx_path: "./certs/admin-special.pfx"
        passphrase: "{{$env.ADMIN_CERT_PASS}}"
      body:
        action: "sensitive_operation"
```

## Prioridade de Certificados

Quando múltiplos certificados são configurados, a ordem de prioridade é:

1. **Certificado do step** (maior prioridade)
2. **Certificado da suite**
3. **Certificado global por matching de domínio**
4. **Nenhum certificado** (requisição prossegue sem client cert)

## Domain Matching

Certificados globais podem ser filtrados por padrões de domínio usando regex:

```yaml
certificates:
  - name: "Exact match"
    domains: ["api.example.com"]

  - name: "Wildcard subdomain"
    domains: ["*.example.com"]  # Matches: api.example.com, test.example.com

  - name: "Multiple patterns"
    domains:
      - "*.api.com"
      - "*.service.com"
      - "exact.domain.com"

  - name: "Complex regex"
    domains: ["api-.*\\.example\\.com"]  # api-v1.example.com, api-prod.example.com
```

## Configuração de TLS Versions

Você pode controlar as versões TLS permitidas para conexões seguras:

### Versões Suportadas
- `TLSv1` - TLS 1.0 (⚠️ Obsoleto, não recomendado)
- `TLSv1.1` - TLS 1.1 (⚠️ Obsoleto, não recomendado)
- `TLSv1.2` - TLS 1.2 (✅ Recomendado)
- `TLSv1.3` - TLS 1.3 (✅ Mais seguro)

### Exemplos de Uso

**Forçar TLS 1.2 ou superior (recomendado):**
```yaml
certificate:
  cert_path: "./certs/client.crt"
  key_path: "./certs/client.key"
  min_version: "TLSv1.2"  # Rejeita TLS 1.0 e 1.1
```

**Permitir apenas TLS 1.3:**
```yaml
certificate:
  cert_path: "./certs/client.crt"
  key_path: "./certs/client.key"
  min_version: "TLSv1.3"
  max_version: "TLSv1.3"
```

**Configuração flexível (TLS 1.2 a 1.3):**
```yaml
certificate:
  pfx_path: "./certs/certificate.pfx"
  passphrase: "{{$env.CERT_PASSWORD}}"
  min_version: "TLSv1.2"
  max_version: "TLSv1.3"
```

**APIs governamentais ou corporativas (exemplo Dataprev):**
```yaml
certificate:
  cert_path: "{{$env.DATAPREV_CERT_PATH}}"
  key_path: "{{$env.DATAPREV_KEY_PATH}}"
  passphrase: "{{$env.DATAPREV_PEM_PASSWORD}}"
  verify: false        # ⚠️ Apenas dev/teste
  min_version: "TLSv1.2"  # Conformidade com requisitos de segurança
  max_version: "TLSv1.3"
```

### Boas Práticas TLS

✅ **Recomendações:**
- **Sempre use `min_version: "TLSv1.2"`** como mínimo (TLS 1.0/1.1 são inseguros)
- **Permita TLS 1.3** quando disponível (`max_version: "TLSv1.3"`)
- **Teste com o servidor** antes de restringir versões
- **Documente requisitos** do servidor no YAML

❌ **Evite:**
- Usar TLS 1.0 ou 1.1 (vulneráveis a ataques)
- Restringir apenas TLS 1.3 sem testar (compatibilidade)
- Deixar sem configuração em ambientes de produção

### Troubleshooting TLS

**Erro: "unsupported protocol"**
```bash
# O servidor não suporta a versão TLS configurada
# Solução: Verifique versões suportadas pelo servidor
openssl s_client -connect api.example.com:443 -tls1_2
openssl s_client -connect api.example.com:443 -tls1_3
```

**Erro: "handshake failure" com min_version**
```yaml
# Tente remover temporariamente para identificar o problema
certificate:
  cert_path: "..."
  key_path: "..."
  # min_version: "TLSv1.2"  # Comentar temporariamente
  # max_version: "TLSv1.3"
```

## Gerando Certificados para Teste

### Certificado Auto-Assinado (PEM)

```bash
# 1. Gerar chave privada (2048-bit RSA)
openssl genrsa -out client.key 2048

# 2. Gerar Certificate Signing Request (CSR)
openssl req -new -key client.key -out client.csr \
  -subj "/C=BR/ST=SP/L=SaoPaulo/O=MyCompany/CN=client"

# 3. Gerar certificado auto-assinado (válido por 365 dias)
openssl x509 -req -days 365 -in client.csr \
  -signkey client.key -out client.crt

# 4. (Opcional) Proteger chave com senha
openssl rsa -aes256 -in client.key -out client-encrypted.key
```

### Converter PEM para PFX

```bash
# Combinar certificado e chave em arquivo PFX
openssl pkcs12 -export \
  -out certificate.pfx \
  -inkey client.key \
  -in client.crt \
  -certfile ca.crt  # Opcional: incluir CA certificate
  # Será solicitada uma senha para o arquivo PFX
```

### Converter PFX para PEM

```bash
# Extrair certificado
openssl pkcs12 -in certificate.pfx -clcerts -nokeys -out client.crt

# Extrair chave privada
openssl pkcs12 -in certificate.pfx -nocerts -out client.key

# Remover senha da chave (se necessário)
openssl rsa -in client.key -out client-no-pass.key
```

## Segurança - Boas Práticas

### 1. Variáveis de Ambiente para Senhas

**SEMPRE** use variáveis de ambiente para senhas de certificados:

```bash
# .env ou export direto
export FLOW_TEST_CERT_PASSWORD="minha-senha-segura"
export FLOW_TEST_PFX_PASSWORD="outra-senha"
export FLOW_TEST_ADMIN_CERT_PASS="admin-senha"
```

```yaml
certificate:
  pfx_path: "./certs/cert.pfx"
  passphrase: "{{$env.CERT_PASSWORD}}"  # ✅ CORRETO
  # passphrase: "senha123"              # ❌ NUNCA faça isso!
```

### 2. Gitignore

O `.gitignore` já está configurado para ignorar certificados:

```gitignore
# SSL/TLS Certificates
*.pfx
*.p12
*.key
*.pem
*.crt
*.cer
*.der
certs/
certificates/
```

### 3. Permissões de Arquivo

Em sistemas Unix/Linux, restrinja permissões:

```bash
# Apenas owner pode ler/escrever
chmod 600 client.key client.crt
chmod 600 certificate.pfx

# Diretório de certificados
chmod 700 certs/
```

### 4. Rotação de Certificados

- Configure alertas para certificados próximos da expiração
- Use variáveis de ambiente para facilitar troca de certificados
- Mantenha backups seguros de certificados expirados (auditoria)

### 5. Ambientes Diferentes

Use arquivos de configuração separados por ambiente:

```yaml
# flow-test.config.dev.yml
globals:
  certificates:
    - pfx_path: "./certs/dev-cert.pfx"
      passphrase: "{{$env.DEV_CERT_PASS}}"

# flow-test.config.prod.yml
globals:
  certificates:
    - pfx_path: "./certs/prod-cert.pfx"
      passphrase: "{{$env.PROD_CERT_PASS}}"
```

## Casos de Uso Reais

### 1. e-CAC (Receita Federal)

```yaml
suite_name: "e-CAC API Test"
node_id: "ecac-test"
base_url: "https://cav.receita.fazenda.gov.br"

certificate:
  pfx_path: "./certs/certificado-digital-ecac.pfx"
  passphrase: "{{$env.ECAC_CERT_PASSWORD}}"

steps:
  - name: "Consultar dados fiscais"
    request:
      method: GET
      url: "/api/consulta"
      params:
        cnpj: "{{company_cnpj}}"
    assert:
      status_code: 200
```

### 2. API Bancária (mTLS)

```yaml
suite_name: "Corporate Banking API"
node_id: "banking-api"
base_url: "https://api.bank.com"

certificate:
  cert_path: "./certs/company-client.crt"
  key_path: "./certs/company-client.key"
  ca_path: "./certs/bank-ca.crt"
  passphrase: "{{$env.BANKING_CERT_PASS}}"

steps:
  - name: "Check account balance"
    request:
      method: GET
      url: "/accounts/{{account_id}}/balance"
    assert:
      status_code: 200
      body:
        balance: { exists: true, type: "number" }
```

### 3. Nota Fiscal Eletrônica (NF-e)

```yaml
suite_name: "NF-e SEFAZ Tests"
node_id: "nfe-test"

# Certificado A1 (PFX) para emissão de NF-e
certificate:
  pfx_path: "./certs/certificado-a1-nfe.pfx"
  passphrase: "{{$env.NFE_CERT_PASSWORD}}"

variables:
  uf: "SP"
  ambiente: "homologacao"  # ou "producao"

steps:
  - name: "Consultar status do serviço"
    request:
      method: POST
      url: "https://nfe{{ambiente}}.fazenda.sp.gov.br/ws/nfestatusservico4.asmx"
      headers:
        Content-Type: "text/xml; charset=utf-8"
      body: "{{xml_status_servico}}"
    assert:
      status_code: 200
```

### 4. Dataprev (Governo - mTLS + OAuth2)

```yaml
# auth-dataprev.yaml
suite_name: "OAuth2 Token with Client Certificate"
node_id: "dataprev"
base_url: "{{$env.DATAPREV_TOKEN_URL}}"

exports: ["access_token"]

steps:
  - name: "Request OAuth2 Token"
    request:
      method: POST
      url: "/token?grant_type=client_credentials"
      headers:
        Authorization: "Basic {{$env.DATAPREV_BASIC_AUTH}}"
        Content-Type: "application/x-www-form-urlencoded"
      body: "grant_type=client_credentials"

      # Certificado PEM com chave separada
      certificate:
        cert_path: "{{$env.DATAPREV_CERT_PATH}}"
        key_path: "{{$env.DATAPREV_KEY_PATH}}"    # ← OBRIGATÓRIO!
        passphrase: "{{$env.DATAPREV_PEM_PASSWORD}}"
        verify: false  # ⚠️ Apenas para desenvolvimento

      timeout: 20000

    assert:
      status_code: 200
      body:
        access_token: { exists: true, type: "string" }

    capture:
      access_token: "body.access_token"
```

**Converter PFX para PEM (Dataprev):**
```bash
# Se você recebeu um certificado PFX da Dataprev
openssl pkcs12 -in dataprev-cert.pfx -clcerts -nokeys -out dataprev.crt
openssl pkcs12 -in dataprev-cert.pfx -nocerts -out dataprev.key

# Configurar no .env
FLOW_TEST_DATAPREV_CERT_PATH=/caminho/completo/dataprev.crt
FLOW_TEST_DATAPREV_KEY_PATH=/caminho/completo/dataprev.key
FLOW_TEST_DATAPREV_PEM_PASSWORD=senha_do_certificado
```

## Troubleshooting

### Erro: "Certificate file not found"

**Causa:** Caminho do arquivo está incorreto.

**Solução:**
```bash
# Verificar se arquivo existe
ls -la ./certs/client.crt

# Caminhos relativos são resolvidos a partir do diretório do projeto
pwd  # Verificar diretório atual
```

### Erro: "unable to load client certificate private key"

**Causa:** Senha incorreta ou formato de arquivo inválido.

**Solução:**
```bash
# Verificar se a senha está correta
openssl rsa -in client.key -check
# Se pedir senha, digite a mesma configurada no YAML

# Verificar formato do certificado
openssl x509 -in client.crt -text -noout

# Verificar arquivo PFX
openssl pkcs12 -info -in certificate.pfx
```

### Erro: "certificate verify failed"

**Causa:** Servidor não confia no certificado ou CA não configurado.

**Solução:**
```yaml
# Adicionar CA certificate
certificate:
  cert_path: "./certs/client.crt"
  key_path: "./certs/client.key"
  ca_path: "./certs/ca-bundle.crt"  # ← Adicione isso
```

### Certificado expirado

```bash
# Verificar validade do certificado
openssl x509 -in client.crt -noout -dates
# Output:
# notBefore=Jan  1 00:00:00 2024 GMT
# notAfter=Dec 31 23:59:59 2024 GMT

# Gerar novo certificado com validade de 2 anos
openssl x509 -req -days 730 -in client.csr -signkey client.key -out client.crt
```

### Logs não mostram aplicação do certificado

Habilite modo verbose:

```bash
# CLI
npx flow-test-engine --verbose tests/certificate-flow.yaml

# Procure por logs:
# [INFO] Certificate service initialized with global certificates
# [INFO] Applied certificate: Corporate API Certificate
```

## CI/CD

### GitHub Actions

```yaml
name: Run Certificate Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup certificates
        env:
          CERT_BASE64: ${{ secrets.CLIENT_CERT_BASE64 }}
          KEY_BASE64: ${{ secrets.CLIENT_KEY_BASE64 }}
        run: |
          mkdir -p certs
          echo "$CERT_BASE64" | base64 -d > certs/client.crt
          echo "$KEY_BASE64" | base64 -d > certs/client.key
          chmod 600 certs/*

      - name: Run tests
        env:
          FLOW_TEST_CERT_PASSWORD: ${{ secrets.CERT_PASSWORD }}
        run: |
          npm test
```

### GitLab CI

```yaml
test-with-certs:
  stage: test
  before_script:
    - mkdir -p certs
    - echo "$CLIENT_CERT_BASE64" | base64 -d > certs/client.crt
    - echo "$CLIENT_KEY_BASE64" | base64 -d > certs/client.key
    - chmod 600 certs/*
  script:
    - npm test
  variables:
    FLOW_TEST_CERT_PASSWORD: $CERT_PASSWORD
```

## Referências

- [OpenSSL Documentation](https://www.openssl.org/docs/)
- [RFC 5280 - X.509 Certificate](https://tools.ietf.org/html/rfc5280)
- [Postman Certificates Guide](https://learning.postman.com/docs/sending-requests/authorization/certificates/)
- [mTLS Best Practices](https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/)

## Suporte

Para problemas ou dúvidas sobre certificados digitais:

1. Verifique este guia primeiro
2. Consulte os exemplos em `tests/certificate-flow.yaml`
3. Habilite logs verbose (`--verbose`)
4. Abra uma issue no GitHub com logs e configuração (sem senhas!)
