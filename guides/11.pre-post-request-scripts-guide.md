# Pre/Post-Request Scripts & Delay Steps

Guia para implementação de scripts antes/depois de requisições e delays manuais no Flow Test Engine.

---

## 1. Pre-Request Scripts

Execute código JavaScript **antes** da requisição HTTP para preparar dados, gerar tokens, computar valores dinâmicos.

### 1.1 Sintaxe YAML

```yaml
steps:
  - name: "Login with dynamic signature"
    pre_request:
      # JavaScript inline
      script: |
        const timestamp = Date.now();
        const signature = crypto.createHmac('sha256', variables.api_secret)
          .update(`${variables.username}:${timestamp}`)
          .digest('hex');

        // Setar variáveis disponíveis no request
        setVariable('timestamp', timestamp);
        setVariable('signature', signature);

        // Modificar request dinamicamente
        request.headers['X-Timestamp'] = timestamp;
        request.headers['X-Signature'] = signature;

      # Ou arquivo externo
      # script_file: "./scripts/auth-signature.js"

      # Timeout do script (padrão: 5000ms)
      timeout: 10000

      # Continuar mesmo se script falhar
      continue_on_error: false

    request:
      method: POST
      url: "/auth/login"
      headers:
        Content-Type: "application/json"
        X-Timestamp: "{{timestamp}}"
        X-Signature: "{{signature}}"
      body:
        username: "{{username}}"
```

### 1.2 API Disponível no Script

```javascript
// --- VARIÁVEIS ---
// Ler variáveis
const value = variables.variable_name;
const envVar = variables.$env.API_KEY;

// Escrever variáveis (disponíveis no request e captures)
setVariable('var_name', value);
setVariable('computed_token', jwt.sign({...}, secret));

// --- REQUEST OBJECT (mutável) ---
request.method;           // "GET", "POST", etc.
request.url;              // URL completa resolvida
request.headers;          // Object - modificável
request.body;             // Object/String - modificável
request.params;           // Query params - modificável
request.timeout;          // Timeout em ms

// --- UTILITIES ---
// Crypto
const hash = crypto.createHash('sha256').update(data).digest('hex');
const hmac = crypto.createHmac('sha256', secret).update(data).digest('hex');

// Base64
const encoded = Buffer.from(text).toString('base64');
const decoded = Buffer.from(encoded, 'base64').toString('utf8');

// JSON
const parsed = JSON.parse(jsonString);
const stringified = JSON.stringify(object);

// UUID
const uuid = crypto.randomUUID();

// Date/Time
const now = Date.now();
const isoDate = new Date().toISOString();

// Faker (se disponível)
const email = faker.internet.email();
const name = faker.person.fullName();

// Logging
console.log('Debug info:', value);
console.error('Error:', error);

// Assertions (opcional - falhar pre-request)
if (!variables.auth_token) {
  throw new Error('auth_token is required');
}
```

---

## 2. Post-Request Scripts

Execute código JavaScript **após** a requisição para processar resposta, validar dados, extrair informações complexas.

### 2.1 Sintaxe YAML

```yaml
steps:
  - name: "Get user and process data"
    request:
      method: GET
      url: "/users/{{user_id}}"

    post_request:
      script: |
        // Acessar resposta completa
        const { status, headers, body } = response;

        // Validações customizadas
        if (status === 200 && !body.email) {
          throw new Error('Email is missing in response');
        }

        // Processar dados complexos
        const permissions = body.roles
          .flatMap(role => role.permissions)
          .filter(p => p.active);

        setVariable('user_permissions', permissions);
        setVariable('is_admin', permissions.includes('admin:*'));

        // Computar métricas
        const responseTimeOk = response.response_time_ms < 1000;
        setVariable('performance_check', responseTimeOk);

        // Logs estruturados
        console.log('User loaded:', body.username);
        console.log('Permissions:', permissions.length);

      # Ou arquivo externo
      # script_file: "./scripts/process-user.js"

      timeout: 5000
      continue_on_error: false

    # Captures regulares ainda funcionam
    capture:
      user_email: "body.email"
      user_name: "body.name"
```

### 2.2 API Disponível no Script

```javascript
// --- RESPONSE OBJECT (imutável) ---
response.status;           // 200, 404, etc.
response.status_code;      // Alias para status
response.headers;          // Object com headers
response.body;             // Object (JSON) ou String
response.data;             // Alias para body (axios)
response.response_time_ms; // Tempo de resposta

// --- VARIÁVEIS (mesmo do pre-request) ---
const value = variables.variable_name;
setVariable('new_var', computed_value);

// --- REQUEST ORIGINAL (imutável) ---
request.method;
request.url;
request.headers;
request.body;

// --- UTILITIES (mesmo do pre-request) ---
// crypto, Buffer, JSON, Date, faker, console, etc.
```

---

## 3. Delay Steps

Adicione pausas explícitas na execução para simular tempo de espera, throttling, ou aguardar processamento assíncrono.

### 3.1 Sintaxe YAML
`
```yaml
steps:
  # Delay simples
  - name: "Wait for async processing"
    delay: 5000  # 5 segundos em ms

  # Delay com interpolação
  - name: "Dynamic wait based on response"
    delay: "{{computed_delay_ms}}"

  # Delay com range aleatório (útil para simular comportamento humano)
  - name: "Random delay"
    delay:
      min: 1000   # 1 segundo
      max: 3000   # 3 segundos

  # Delay condicional
  - name: "Wait if slow API"
    delay: 2000
    metadata:
      skip: "{{response_time_ms}} < 500"  # Pula se API foi rápida
```

### 3.2 Exemplos Práticos

**Throttling entre requests:**
```yaml
steps:
  - name: "Create user {{user.id}}"
    iterate:
      over: "{{users_list}}"
      as: "user"
    request:
      method: POST
      url: "/users"
      body: "{{user}}"

  # Delay após cada iteração
  - name: "Rate limit protection"
    delay: 1000  # 1s entre cada criação
```

**Aguardar processamento assíncrono:**
```yaml
steps:
  - name: "Trigger batch job"
    request:
      method: POST
      url: "/batch/process"
    capture:
      job_id: "body.job_id"

  - name: "Wait for job processing"
    delay: 30000  # 30 segundos

  - name: "Check job status"
    request:
      method: GET
      url: "/batch/{{job_id}}/status"
```

---

## 4. Ordem de Execução

```
┌─────────────────────────────────────┐
│ 1. PRE-REQUEST SCRIPT               │
│    - Modifica request                │
│    - Seta variáveis                  │
│    - Validações pré-voo              │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│ 2. INTERPOLAÇÃO DE VARIÁVEIS        │
│    - Substitui {{var}} em request    │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│ 3. HTTP REQUEST                      │
│    - Executa requisição              │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│ 4. POST-REQUEST SCRIPT              │
│    - Processa response               │
│    - Validações customizadas         │
│    - Seta variáveis                  │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│ 5. CAPTURES (JMESPath)              │
│    - Extrai dados de response        │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│ 6. ASSERTIONS                        │
│    - Valida response                 │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│ 7. SCENARIOS (condicionais)         │
│    - Executa lógica condicional      │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│ 8. DELAY (se configurado)           │
│    - Pausa antes do próximo step     │
└─────────────────────────────────────┘
```

---

## 5. Exemplo Completo: OAuth2 com PKCE

```yaml
suite_name: "OAuth2 PKCE Flow"
node_id: "oauth-pkce"
base_url: "{{auth_server}}"

steps:
  # Step 1: Gerar PKCE challenge
  - name: "Generate PKCE verifier and challenge"
    pre_request:
      script: |
        const crypto = require('crypto');

        // Gerar code_verifier (43-128 chars)
        const verifier = crypto.randomBytes(32).toString('base64url');

        // Gerar code_challenge (SHA256 do verifier)
        const challenge = crypto
          .createHash('sha256')
          .update(verifier)
          .digest('base64url');

        setVariable('code_verifier', verifier);
        setVariable('code_challenge', challenge);
        setVariable('state', crypto.randomUUID());

        console.log('PKCE generated:', { verifier, challenge });

    request:
      method: GET
      url: "/oauth/authorize"
      params:
        client_id: "{{client_id}}"
        redirect_uri: "{{redirect_uri}}"
        response_type: "code"
        code_challenge: "{{code_challenge}}"
        code_challenge_method: "S256"
        state: "{{state}}"

    capture:
      authorization_code: "body.code"

  # Step 2: Delay simulando redirecionamento
  - name: "Simulate user interaction delay"
    delay:
      min: 500
      max: 2000

  # Step 3: Trocar code por token
  - name: "Exchange code for token"
    pre_request:
      script: |
        // Preparar body como form-urlencoded
        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';

    request:
      method: POST
      url: "/oauth/token"
      body:
        grant_type: "authorization_code"
        code: "{{authorization_code}}"
        client_id: "{{client_id}}"
        redirect_uri: "{{redirect_uri}}"
        code_verifier: "{{code_verifier}}"

    post_request:
      script: |
        const { body } = response;

        // Decodificar JWT para extrair info
        const [header, payload, signature] = body.access_token.split('.');
        const decoded = JSON.parse(
          Buffer.from(payload, 'base64url').toString()
        );

        setVariable('token_expires_at', decoded.exp * 1000);
        setVariable('token_scope', decoded.scope);
        setVariable('user_id', decoded.sub);

        console.log('Token decoded:', {
          user: decoded.sub,
          expires: new Date(decoded.exp * 1000).toISOString()
        });

    capture:
      access_token: "body.access_token"
      refresh_token: "body.refresh_token"
```

---

## 6. Casos de Uso Comuns

### 6.1 Assinatura de Requisições (AWS Signature V4)

```yaml
pre_request:
  script: |
    const crypto = require('crypto');

    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, '');
    const date = timestamp.slice(0, 8);

    const canonicalRequest = `${request.method}\n${request.url}\n\n...`;
    const stringToSign = `AWS4-HMAC-SHA256\n${timestamp}\n...`;

    const signature = crypto.createHmac('sha256', signingKey)
      .update(stringToSign)
      .digest('hex');

    request.headers['Authorization'] = `AWS4-HMAC-SHA256 Credential=...`;
```

### 6.2 Rate Limiting Dinâmico

```yaml
post_request:
  script: |
    const remaining = parseInt(response.headers['x-ratelimit-remaining']);
    const resetTime = parseInt(response.headers['x-ratelimit-reset']);

    if (remaining < 10) {
      const waitMs = (resetTime * 1000) - Date.now();
      setVariable('dynamic_delay', Math.max(waitMs, 0));
      console.warn(`Rate limit low: ${remaining} remaining`);
    }

# Próximo step usa o delay computado
- name: "Wait if rate limited"
  delay: "{{dynamic_delay}}"
  metadata:
    skip: "!variables.dynamic_delay"
```

### 6.3 Token Refresh Automático

```yaml
pre_request:
  script: |
    const expiresAt = variables.token_expires_at || 0;
    const now = Date.now();

    if (now >= expiresAt - 60000) { // Renovar 1min antes
      console.log('Token expiring soon, need refresh');
      setVariable('needs_token_refresh', true);
    }
```

### 6.4 Processamento de Pagination

```yaml
post_request:
  script: |
    const { body } = response;

    // Acumular items de todas as páginas
    const allItems = variables.accumulated_items || [];
    allItems.push(...body.items);
    setVariable('accumulated_items', allItems);

    // Verificar se há próxima página
    if (body.next_page) {
      setVariable('has_next_page', true);
      setVariable('next_page_url', body.next_page);
    } else {
      setVariable('has_next_page', false);
      console.log(`Total items collected: ${allItems.length}`);
    }
```

---

## 7. Tipos TypeScript (Implementação)

```typescript
// Pre/Post-Request Script Config
interface ScriptConfig {
  script?: string;              // JavaScript inline
  script_file?: string;         // Caminho para arquivo .js
  timeout?: number;             // Timeout em ms (padrão: 5000)
  continue_on_error?: boolean;  // Padrão: false
}

// Delay Config
type DelayConfig =
  | number                      // Delay fixo em ms
  | string                      // Delay com interpolação
  | {
      min: number;              // Delay mínimo em ms
      max: number;              // Delay máximo em ms
    };

// TestStep atualizado
interface TestStep {
  name: string;
  pre_request?: ScriptConfig;   // NOVO
  request?: RequestDetails;
  post_request?: ScriptConfig;  // NOVO
  delay?: DelayConfig;          // NOVO
  assert?: Assertions;
  capture?: Record<string, string>;
  // ... outras propriedades existentes
}
```

---

## 8. Segurança e Boas Práticas

### ✅ Permitido
- Crypto nativo (hashing, HMAC, randomBytes)
- Buffer operations (base64, encoding)
- JSON parse/stringify
- Date/Time operations
- Math operations
- Faker.js (geração de dados)

### ⚠️ Com Cuidado
- `require()` - apenas módulos built-in do Node.js
- `console.log` - use para debug, não em produção
- Modificação de `request` - valide antes de executar

### ❌ Não Permitido (sandbox)
- `eval()` e `Function()` - bloqueados por segurança
- File system (`fs`) - não disponível
- Network (`http`, `net`) - não disponível
- Process (`process.exit()`) - não disponível
- Loops infinitos - timeout automático

### Recomendações
1. **Timeout adequado**: Scripts complexos podem precisar de mais tempo
2. **Logging**: Use `console.log` para debug durante desenvolvimento
3. **Error handling**: Use `try/catch` em scripts para evitar falhas inesperadas
4. **Reutilização**: Mova scripts complexos para arquivos externos (`script_file`)
5. **Testes**: Valide scripts em ambiente de teste antes de usar em produção
6. **Delay razoável**: Evite delays muito longos (use polling em vez de delay fixo longo)

---

## 9. Implementação Sugerida

### Prioridade 1 (MVP)
- [x] Pre-request scripts (inline)
- [x] Post-request scripts (inline)
- [x] Delay fixo (number)
- [x] API básica: `variables`, `setVariable()`, `request`, `response`
- [x] Sandbox básico (vm2 ou isolated-vm)

### Prioridade 2
- [ ] Script files externos (`script_file`)
- [ ] Delay com range (`{min, max}`)
- [ ] Delay com interpolação
- [ ] Utilities: crypto, Buffer, faker
- [ ] Error handling robusto

### Prioridade 3
- [ ] TypeScript support em scripts
- [ ] Debugging de scripts
- [ ] Métricas de execução de scripts
- [ ] Cache de scripts compilados

---

## 10. Migração e Compatibilidade

Scripts não quebram funcionalidades existentes:
- `capture` continua funcionando (JMESPath)
- `assert` continua funcionando
- `scenarios` continua funcionando

Scripts complementam:
- Use `pre_request` para preparar dados complexos
- Use `post_request` para validações customizadas além de `assert`
- Use `delay` quando precisar de pausa explícita

---

**Status**: 📝 Documentação pronta para implementação
**Próximos passos**: Criar issues para implementação incremental
