# Flow Test Engine Schema Catalog

## Visão Geral

O Flow Test Engine exporta um **catálogo de schema estruturado** em formato JSON que contém toda a documentação, tipos, exemplos e padrões suportados pelo engine. Este schema é projetado especificamente para ser consumido por ferramentas externas como **extensões IDE** (VS Code, IntelliJ, etc.) para fornecer:

- ✅ **Autocomplete inteligente** com todas as propriedades disponíveis
- ✅ **Documentação inline** (hover) com descrições e exemplos
- ✅ **Validação em tempo real** com tipos e constraints
- ✅ **Snippets dinâmicos** gerados automaticamente
- ✅ **Detecção de atualizações** via versionamento semântico

## Uso

### Exportar Schema

```bash
# Exibir no stdout
flow-test schema --format json

# Salvar em arquivo
flow-test schema --format json > flow-test-engine.schema.json

# Inspecionar estrutura específica
flow-test schema --format json | jq '.structures.TestSuite'

# Ver exemplos disponíveis
flow-test schema --format json | jq '.examples[].name'
```

### Help

```bash
flow-test schema --help
```

## Estrutura do Schema

O schema exportado segue a interface `FlowTestSchema`:

```typescript
{
  "version": "1.1.33",                    // Versão do engine (package.json)
  "generatedAt": "2024-01-01T12:00:00Z",  // Timestamp ISO 8601
  "engine": {...},                        // Metadados do engine
  "structures": {...},                    // Definições de estruturas (TestSuite, TestStep, etc.)
  "types": {...},                         // Tipos reutilizáveis (enums, unions)
  "examples": [...],                      // Exemplos completos em YAML
  "interpolation": {...},                 // Padrões de interpolação e helpers
  "cli": {...}                            // Documentação CLI (comandos, flags)
}
```

### 1. Structures

Definições completas de todas as estruturas YAML suportadas:

```json
{
  "structures": {
    "TestSuite": {
      "name": "TestSuite",
      "description": "Top-level test suite definition",
      "documentation": "Defines a complete test suite...",
      "required": ["node_id", "suite_name", "steps"],
      "properties": {
        "node_id": {
          "name": "node_id",
          "type": "string",
          "description": "Unique identifier for the suite (kebab-case)",
          "required": true,
          "interpolable": false,
          "examples": ["user-auth-test", "api-integration"],
          "constraints": {
            "pattern": "^[a-z0-9-]+$"
          }
        },
        "suite_name": { ... },
        "steps": {
          "type": "array",
          "items": { "$ref": "TestStep" },
          ...
        }
      },
      "relations": [
        {
          "target": "TestStep",
          "type": "contains",
          "via": "steps",
          "description": "A suite contains multiple test steps"
        }
      ]
    },
    "TestStep": { ... },
    "RequestDetails": { ... },
    ...
  }
}
```

**Estruturas disponíveis:**
- `TestSuite` - Suite completa de testes
- `TestStep` - Passo individual de teste
- `RequestDetails` - Configuração de requisição HTTP
- `Assertions` - Regras de validação de resposta
- `AssertionChecks` - Operadores de asserção
- `InputConfig` - Configuração de input interativo
- `IterationConfig` - Configuração de loops
- `ConditionalScenario` - Cenários condicionais
- `StepCallConfig` - Chamada cross-suite
- `FlowDependency` - Dependência entre suites
- `CertificateConfig` - Certificados mTLS
- `HookAction` - Ações de lifecycle hooks (v2.0+)

### 2. Types

Tipos reutilizáveis (enums, unions, interfaces):

```json
{
  "types": {
    "HttpMethod": {
      "name": "HttpMethod",
      "kind": "enum",
      "description": "HTTP request methods",
      "values": [
        {
          "value": "GET",
          "description": "Retrieve resource",
          "example": "GET /users"
        },
        {
          "value": "POST",
          "description": "Create resource",
          "example": "POST /users"
        },
        ...
      ]
    },
    "PriorityLevel": {
      "kind": "enum",
      "values": [
        { "value": "critical", "description": "Critical tests (smoke, core)" },
        { "value": "high", "description": "High priority tests" },
        { "value": "medium", "description": "Medium priority tests" },
        { "value": "low", "description": "Low priority tests (edge cases)" }
      ]
    },
    ...
  }
}
```

### 3. Examples

Exemplos completos e funcionais em YAML:

```json
{
  "examples": [
    {
      "name": "Basic Authentication Flow",
      "description": "Simple login with token capture and reuse",
      "category": "authentication",
      "complexity": "basic",
      "features": ["capture", "interpolation", "assertions"],
      "yaml": "suite_name: \"Auth Flow\"\nnode_id: \"auth-flow\"\n..."
    },
    {
      "name": "Lifecycle Hooks",
      "category": "hooks",
      "complexity": "advanced",
      "features": ["hooks", "compute", "metrics", "logging"],
      "yaml": "..."
    },
    ...
  ]
}
```

**Categorias de exemplos:**
- `authentication` - Fluxos de autenticação
- `iteration` - Loops e bulk operations
- `conditionals` - Lógica condicional
- `input` - Inputs interativos
- `hooks` - Lifecycle hooks (v2.0+)

### 4. Interpolation

Catálogo completo de padrões de interpolação de variáveis:

```json
{
  "interpolation": {
    "description": "Variable interpolation system...",
    "patterns": [
      {
        "name": "Basic Variable",
        "syntax": "{{variable}}",
        "description": "Reference to a local or captured variable",
        "examples": ["{{user_id}}", "{{auth_token}}"],
        "applicableTo": ["url", "headers", "body", "params"]
      },
      {
        "name": "Faker Data",
        "syntax": "{{$faker.category.method}}",
        "description": "Generate fake data using Faker.js",
        "examples": ["{{$faker.internet.email}}", "{{$faker.person.firstName}}"]
      },
      ...
    ],
    "faker": {
      "categories": [
        {
          "name": "person",
          "description": "Person-related data",
          "methods": [
            {
              "name": "firstName",
              "syntax": "{{$faker.person.firstName}}",
              "example": "John"
            },
            ...
          ]
        },
        ...
      ]
    },
    "javascript": {
      "description": "Execute JavaScript expressions inline",
      "globals": ["Date", "Math", "JSON", "Buffer", "crypto"],
      "patterns": [
        {
          "name": "Current Timestamp",
          "syntax": "{{$js:Date.now()}}",
          "example": "1704110400000"
        },
        ...
      ]
    },
    "environment": {
      "description": "Environment variables loaded from .env files",
      "prefix": "FLOW_TEST_",
      "examples": [
        {
          "name": "API_KEY",
          "example": "{{$env.API_KEY}} reads FLOW_TEST_API_KEY"
        },
        ...
      ]
    }
  }
}
```

### 5. CLI

Documentação completa dos comandos e flags:

```json
{
  "cli": {
    "command": "flow-test",
    "description": "Flow Test Engine CLI - Execute API tests from YAML definitions",
    "flags": [
      {
        "name": "--config",
        "alias": "-c",
        "type": "string",
        "description": "Path to configuration file",
        "example": "flow-test --config ./flow-test.config.yml"
      },
      ...
    ],
    "subcommands": [
      {
        "name": "schema",
        "description": "Export engine schema catalog",
        "example": "flow-test schema --format json"
      },
      {
        "name": "init",
        "description": "Initialize a new Flow Test project",
        "example": "flow-test init"
      },
      ...
    ]
  }
}
```

## Consumindo o Schema (Extensões IDE)

### 1. Download e Caching

```typescript
// Exemplo para VS Code extension
import * as vscode from 'vscode';
import { exec } from 'child_process';

interface SchemaCache {
  version: string;
  schema: FlowTestSchema;
  lastUpdate: string;
}

async function updateSchema(context: vscode.ExtensionContext): Promise<FlowTestSchema> {
  // Executar comando schema
  const schemaJson = await new Promise<string>((resolve, reject) => {
    exec('flow-test schema --format json', (error, stdout) => {
      if (error) reject(error);
      else resolve(stdout);
    });
  });

  const schema = JSON.parse(schemaJson);

  // Salvar no globalState com versão
  await context.globalState.update('flow-test-schema', {
    version: schema.version,
    schema: schema,
    lastUpdate: new Date().toISOString()
  } as SchemaCache);

  return schema;
}

async function getSchema(context: vscode.ExtensionContext): Promise<FlowTestSchema> {
  const cached = context.globalState.get<SchemaCache>('flow-test-schema');

  // Verificar se precisa atualizar (nova versão disponível)
  const currentVersion = await getCurrentEngineVersion();

  if (!cached || cached.version !== currentVersion) {
    return await updateSchema(context);
  }

  return cached.schema;
}
```

### 2. Gerando Autocomplete

```typescript
// Exemplo: Autocomplete para propriedades de TestSuite
function provideCompletionItems(
  schema: FlowTestSchema,
  document: vscode.TextDocument,
  position: vscode.Position
): vscode.CompletionItem[] {
  const items: vscode.CompletionItem[] = [];
  const structure = schema.structures.TestSuite;

  for (const [propName, propDef] of Object.entries(structure.properties)) {
    const item = new vscode.CompletionItem(propName, vscode.CompletionItemKind.Property);

    // Documentação inline
    item.documentation = new vscode.MarkdownString(
      `**${propDef.description}**\n\n` +
      `Type: \`${propDef.type}\`\n\n` +
      `Required: ${propDef.required ? '✅ Yes' : '❌ No'}\n\n` +
      (propDef.examples ? `Examples:\n\`\`\`yaml\n${propDef.examples[0]}\n\`\`\`` : '')
    );

    // Detail
    item.detail = `${propDef.type}${propDef.required ? ' (required)' : ''}`;

    // Snippet com valor default/exemplo
    if (propDef.type === 'string') {
      item.insertText = new vscode.SnippetString(`${propName}: "\${1:${propDef.examples?.[0] || 'value'}}"`);
    } else if (propDef.type === 'array') {
      item.insertText = new vscode.SnippetString(`${propName}:\n  - \${1:item}`);
    } else if (propDef.type === 'object') {
      item.insertText = new vscode.SnippetString(`${propName}:\n  \${1:key}: \${2:value}`);
    }

    items.push(item);
  }

  return items;
}
```

### 3. Validação Dinâmica

```typescript
// Validar constraints em tempo real
function validateProperty(
  value: any,
  propDef: PropertyDefinition
): vscode.Diagnostic[] {
  const diagnostics: vscode.Diagnostic[] = [];

  // Tipo
  if (propDef.type && typeof value !== propDef.type) {
    diagnostics.push(new vscode.Diagnostic(
      range,
      `Expected type '${propDef.type}' but got '${typeof value}'`,
      vscode.DiagnosticSeverity.Error
    ));
  }

  // Constraints
  if (propDef.constraints) {
    // Pattern (regex)
    if (propDef.constraints.pattern && typeof value === 'string') {
      const regex = new RegExp(propDef.constraints.pattern);
      if (!regex.test(value)) {
        diagnostics.push(new vscode.Diagnostic(
          range,
          `Value does not match pattern: ${propDef.constraints.pattern}`,
          vscode.DiagnosticSeverity.Error
        ));
      }
    }

    // Min/Max length
    if (propDef.constraints.minLength && value.length < propDef.constraints.minLength) {
      diagnostics.push(new vscode.Diagnostic(
        range,
        `Minimum length is ${propDef.constraints.minLength}`,
        vscode.DiagnosticSeverity.Warning
      ));
    }
  }

  // Enum values
  if (propDef.enum && !propDef.enum.includes(value)) {
    diagnostics.push(new vscode.Diagnostic(
      range,
      `Value must be one of: ${propDef.enum.join(', ')}`,
      vscode.DiagnosticSeverity.Error
    ));
  }

  return diagnostics;
}
```

### 4. Hover Documentation

```typescript
// Hover com documentação completa
function provideHover(
  schema: FlowTestSchema,
  propertyName: string
): vscode.Hover {
  const structure = schema.structures.TestStep;
  const propDef = structure.properties[propertyName];

  if (!propDef) return null;

  const markdown = new vscode.MarkdownString();
  markdown.appendMarkdown(`### ${propDef.name}\n\n`);
  markdown.appendMarkdown(`${propDef.description}\n\n`);

  if (propDef.documentation) {
    markdown.appendMarkdown(`${propDef.documentation}\n\n`);
  }

  markdown.appendMarkdown(`**Type:** \`${propDef.type}\`\n\n`);
  markdown.appendMarkdown(`**Required:** ${propDef.required ? '✅ Yes' : '❌ No'}\n\n`);

  if (propDef.default !== undefined) {
    markdown.appendMarkdown(`**Default:** \`${propDef.default}\`\n\n`);
  }

  if (propDef.enum) {
    markdown.appendMarkdown(`**Allowed values:** ${propDef.enum.map(v => `\`${v}\``).join(', ')}\n\n`);
  }

  if (propDef.examples && propDef.examples.length > 0) {
    markdown.appendMarkdown(`**Examples:**\n\`\`\`yaml\n${propDef.examples.join('\n')}\n\`\`\`\n\n`);
  }

  if (propDef.since) {
    markdown.appendMarkdown(`_Since version ${propDef.since}_\n`);
  }

  return new vscode.Hover(markdown);
}
```

### 5. Snippets Dinâmicos

```typescript
// Gerar snippets a partir dos examples
function generateSnippets(schema: FlowTestSchema): vscode.CompletionItem[] {
  return schema.examples.map(example => {
    const item = new vscode.CompletionItem(
      `Example: ${example.name}`,
      vscode.CompletionItemKind.Snippet
    );

    item.documentation = new vscode.MarkdownString(
      `**${example.description}**\n\n` +
      `Category: ${example.category}\n\n` +
      `Complexity: ${example.complexity}\n\n` +
      `Features: ${example.features?.join(', ')}`
    );

    item.insertText = new vscode.SnippetString(example.yaml);
    item.sortText = `z-${example.complexity}`;  // Ordenar por complexidade

    return item;
  });
}
```

## Versionamento e Atualizações

### Estratégia de Atualização

1. **Cache local** do schema com timestamp
2. **Verificação periódica** de nova versão (ex: a cada 24h ou ao abrir projeto)
3. **Comparação de versão** usando `schema.version` vs versão instalada do engine
4. **Update automático** em background se detectar nova versão
5. **Notificação ao usuário** sobre novas features (opcional)

```typescript
async function checkForUpdates(context: vscode.ExtensionContext) {
  const cached = context.globalState.get<SchemaCache>('flow-test-schema');
  const lastCheck = context.globalState.get<string>('last-schema-check');

  // Verificar a cada 24h
  const shouldCheck = !lastCheck ||
    (Date.now() - new Date(lastCheck).getTime() > 24 * 60 * 60 * 1000);

  if (!shouldCheck) return;

  const currentVersion = await getCurrentEngineVersion();

  if (!cached || cached.version !== currentVersion) {
    await updateSchema(context);

    vscode.window.showInformationMessage(
      `Flow Test Engine schema updated to v${currentVersion}`,
      'View Changes'
    ).then(selection => {
      if (selection === 'View Changes') {
        // Abrir changelog ou documentação
      }
    });
  }

  await context.globalState.update('last-schema-check', new Date().toISOString());
}
```

## Exemplo Completo: Extension Activation

```typescript
import * as vscode from 'vscode';
import { FlowTestSchema } from './types';

let schema: FlowTestSchema | undefined;

export async function activate(context: vscode.ExtensionContext) {
  // Carregar/atualizar schema
  schema = await getOrUpdateSchema(context);

  // Verificar updates periodicamente
  setInterval(() => checkForUpdates(context), 60 * 60 * 1000);  // Cada hora

  // Registrar providers
  context.subscriptions.push(
    vscode.languages.registerCompletionItemProvider(
      { language: 'yaml', pattern: '**/*.yaml' },
      {
        provideCompletionItems(document, position) {
          return provideCompletionItems(schema!, document, position);
        }
      },
      ':', ' '  // Trigger characters
    )
  );

  context.subscriptions.push(
    vscode.languages.registerHoverProvider(
      { language: 'yaml', pattern: '**/*.yaml' },
      {
        provideHover(document, position) {
          const range = document.getWordRangeAtPosition(position);
          const word = document.getText(range);
          return provideHover(schema!, word);
        }
      }
    )
  );

  // Diagnósticos (validação)
  const diagnosticCollection = vscode.languages.createDiagnosticCollection('flow-test');
  context.subscriptions.push(diagnosticCollection);

  vscode.workspace.onDidChangeTextDocument(event => {
    if (event.document.languageId === 'yaml') {
      validateDocument(event.document, schema!, diagnosticCollection);
    }
  });
}
```

## Troubleshooting

### Schema não encontrado

```bash
# Verificar se comando está disponível
flow-test schema --help

# Se não estiver, reinstalar engine
npm install -g flow-test-engine

# Ou usar npx
npx flow-test-engine schema --format json
```

### Versão desatualizada

```bash
# Verificar versão instalada
flow-test --version

# Atualizar engine
npm update -g flow-test-engine

# Gerar novo schema
flow-test schema --format json > flow-test-engine.schema.json
```

### JSON inválido

```bash
# Validar JSON
flow-test schema --format json | jq empty

# Se erro, reportar issue com output de debug
flow-test schema --format json 2>&1 | tee schema-error.log
```

## Referências

- **Código fonte**: `src/services/schema-generator.service.ts`
- **Tipos**: `src/types/schema.types.ts`
- **Comando CLI**: `src/commands/schema.ts`
- **Testes**: `tests/services/schema-generator.service.test.ts`
- **Documentação YAML**: [guides/4.yaml-syntax-reference.md](4.yaml-syntax-reference.md)

## Changelog

### v1.1.33 (2025-10-23)
- 🎉 **NOVO**: Comando `flow-test schema --format json`
- ✅ Schema completo com 12 estruturas principais
- ✅ 6 padrões de interpolação documentados
- ✅ 6 exemplos completos em múltiplas categorias
- ✅ Versionamento automático via package.json
- ✅ 41 testes unitários garantindo completude

### Próximas Features
- [ ] Suporte a `--format markdown` para documentação
- [ ] Suporte a `--format typescript` para types
- [ ] Schema diff entre versões
- [ ] Validação de YAML contra schema via CLI
