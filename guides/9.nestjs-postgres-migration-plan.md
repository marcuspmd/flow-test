# Plano de Migração para NestJS + Postgres

> Documento estratégico para guiar a evolução do Flow Test Engine para uma arquitetura baseada em NestJS, com persistência em PostgreSQL, execução assíncrona via filas e salvaguardas de segurança contra código malicioso.

---

## 1. Objetivos e Escopo

1. **Replatforming**: portar o motor atual (TypeScript + execução em memória) para um backend NestJS modular.
2. **Persistência completa**: armazenar suites, execuções, logs, variáveis e auditoria em PostgreSQL.
3. **Execução assíncrona e escalável**: usar filas para orquestrar execuções (iniciar, pausar, retomar, retry manual).
4. **Interatividade**: expor APIs e painéis para acompanhar status em tempo real, aprovar inputs e acionar retries.
5. **Segurança reforçada**: impedir injeção de JavaScript e outros ataques quando processarmos YAML/JS dinâmico.
6. **Paridade funcional**: tudo que o engine atual faz deve continuar funcionando, com o “plus” de histórico completo e ferramentas operacionais.

### Fora de escopo imediato

- UI Web detalhada (pode ser entregue em fase posterior, mas endpoints e contratos devem estar prontos).
- Migração de relatórios HTML para outra stack (reaproveitar pipeline existente inicialmente).

---

## 2. Visão Geral do Sistema Atual

| Responsabilidade | Arquivo/Serviço atual | Observações |
| --- | --- | --- |
| Descoberta de suites YAML | `src/core/discovery.ts` | Carrega arquivos e valida schema |
| Orquestração de execução | `src/core/engine.ts` / `src/services/execution.ts` | Percorre steps, chama serviços HTTP/assertion |
| HTTP | `src/services/http.service.ts` | axios + tratamento básico |
| Assert | `src/services/assertion.service.ts` | Tipos ricos (equals, contains, regex, etc.) |
| Variáveis & Faker | `src/services/variable.service.ts` | Interpola env, faker, js |
| Capturas JMESPath | `src/services/capture.service.ts` | Extrai dados da resposta |
| Registro global | `src/services/global-registry.service.ts` | Compartilha variáveis entre suites |

Limitações atuais:
- Execução in-memory (sem persistência histórica).
- Falta de orchestration queue/backpressure.
- Manual retry demandaria reexecutar na mão a CLI.
- Entrada de JS customizado roda no mesmo processo sem sandboxing profundo.

---

## 3. Arquitetura Alvo com NestJS

### 3.1 Componentes Macro

1. **API Gateway (NestJS HTTP Layer)**
   - Endpoints REST/GraphQL para gerir suites, execuções, retries, relatórios.
   - Autenticação + autorização (JWT + RBAC).
2. **Flow Management Module**
   - CRUD de suites/versões, upload de YAML, validação e parsing.
3. **Execution Orchestrator Module**
   - Agenda execuções, envia jobs para fila, monitora progresso.
4. **Worker Module**
   - Processa jobs da fila (BullMQ/Redis) com engine adaptado ao Nest.
5. **Persistence Module (TypeORM)**
   - Repositórios para todas as entidades (Postgres).
6. **Security & Sandbox Module**
   - Execução isolada para JS/faker avançado.
7. **Observability Module**
   - Logs estruturados, métricas, tracing (OpenTelemetry).
8. **CLI/Background Adapters**
   - Mantém capacidade de rodar flows via CLI, agora usando Nest CLI ou scripts que chamam os serviços internos.

### 3.2 Diagrama Textual

```
[Client/UI/CLI]
    |  (REST/WebSocket)
    v
[Nest API Gateway] --(DTO/Validation)--> [Execution Orchestrator]
    |                                  \
    |                                   -> [Queue (Redis/BullMQ)] -> [Worker(s)]
    |                                           |                        |
    |                                           v                        v
    |                                   [Flow Executor Service] --> [Services HTTP/Assert/Capture]
    |                                           |                        |
    v                                           v                        v
[Postgres] <-------------------------------- [Persistence Layer & Event Store]
    |
    -> [Reporting/Analytics] / [Audit Trail]
```

---

## 4. Mapeamento de Módulos NestJS

| Módulo | Objetivo | Principais Providers |
| --- | --- | --- |
| `AppModule` | Bootstrap e configuração | ConfigService, HealthController |
| `AuthModule` | Segurança, RBAC, API Tokens | AuthController, JwtStrategy, RolesGuard |
| `FlowModule` | CRUD de suites/versões | FlowController, FlowService, FlowRepository |
| `ExecutionModule` | Orquestra execuções & queue | ExecutionController, ExecutionService, QueueProducer, QueueConsumer |
| `WorkerModule` | Processamento assíncrono | BullModule consumers, FlowRunnerService |
| `PersistenceModule` | Conexão Postgres (TypeORM) | TypeOrmModule, Repositories |
| `SecurityModule` | Sandboxing/validadores | ScriptSandboxService, InputSanitizer |
| `ObservabilityModule` | Logs/metrics | TelemetryService, AuditLogService |
| `AdminModule` | Operações (retry, reprocessamento) | AdminController, RetryService |

---

## 5. PostgreSQL – Modelo de Dados

### 5.1 Entidades Principais

| Tabela | Finalidade | Relacionamentos |
| --- | --- | --- |
| `flow_suite` | Agrupa suites YAML (por `node_id`) | 1:N com `flow_version` |
| `flow_version` | Versões versionadas do YAML | N:1 `flow_suite`, 1:N `flow_run` |
| `flow_run` | Instância de execução | N:1 `flow_version`, 1:N `step_run`, 1:N `flow_run_event` |
| `step_run` | Execução de step individual | N:1 `flow_run`, 1:N `step_log` |
| `step_log` | Logs de step (mensagens, requests, asserts) | N:1 `step_run` |
| `variable_snapshot` | Valores interpolados/capturados | N:1 `flow_run` (podendo referenciar step) |
| `manual_retry_request` | Solicitações de retry | N:1 `flow_run`, N:1 `step_run`, N:1 `user` |
| `queue_job` | Metadados do job na fila | N:1 `flow_run` |
| `user_account` | Usuários do sistema | 1:N `manual_retry_request`, `audit_log` |
| `api_token` | Credenciais de automação | N:1 `user_account` |
| `audit_log` | Trilha de ações (CRUD, retries, aprovações) | N:1 `user_account`, referencia IDs alvo |

### 5.2 Colunas Recomendadas

#### `flow_suite`
- `id` (UUID, PK)
- `node_id` (varchar, único, index)
- `name`, `description`
- `default_priority` (enum: critical/high/medium/low)
- `tags` (text[])
- `created_at`, `updated_at`

#### `flow_version`
- `id` (UUID)
- `suite_id` (FK)
- `version` (int incremental)
- `yaml_raw` (text)
- `yaml_hash` (char(64))
- `effective_variables` (jsonb) – merge de vars globais + anchors resolvidos
- `compiled_config` (jsonb) – representação normalizada
- `created_by` (FK user)
- `created_at`

#### `flow_run`
- `id` (UUID)
- `version_id` (FK)
- `status` (enum: queued, running, waiting_input, completed, failed, cancelled)
- `trigger_source` (enum: cli, api, schedule, dependency)
- `priority` (enum)
- `requested_by` (FK user/token)
- `queued_at`, `started_at`, `finished_at`
- `queue_job_id` (FK)
- `input_payload` (jsonb) – parâmetros iniciais
- `result_summary` (jsonb) – estatísticas e informações finais

#### `step_run`
- `id` (UUID)
- `flow_run_id` (FK)
- `step_index` (int)
- `step_name` (text)
- `status` (enum: pending, running, waiting_input, success, warning, failed, skipped, aborted)
- `request_snapshot` (jsonb)
- `response_snapshot` (jsonb)
- `assertions` (jsonb)
- `captures` (jsonb)
- `error_details` (jsonb)
- `started_at`, `finished_at`, `duration_ms`

#### `step_log`
- `id` (serial)
- `step_run_id` (FK)
- `log_level` (enum: info, warn, error, debug)
- `message` (text)
- `payload` (jsonb)
- `timestamp`

#### `variable_snapshot`
- `id` (serial)
- `flow_run_id` (FK)
- `step_run_id` (nullable FK)
- `scope` (enum: suite, step, global)
- `key` (varchar)
- `value` (jsonb)
- `source` (enum: variable, capture, input, export)
- `created_at`

#### `manual_retry_request`
- `id` (UUID)
- `flow_run_id` (FK)
- `step_run_id` (FK)
- `requested_by` (FK user)
- `reason` (text)
- `status` (enum: pending, approved, rejected, executed)
- `resolution_notes` (text)
- `created_at`, `resolved_at`

#### `queue_job`
- `id` (varchar) – ID da fila
- `flow_run_id` (FK)
- `queue_name` (varchar)
- `state` (enum: waiting, stalled, failed, completed)
- `attempts_made` (int)
- `max_attempts` (int)
- `last_error` (text)
- `created_at`, `updated_at`

#### `user_account`
- `id` (UUID)
- `email`, `name`
- `password_hash` ou integração SSO
- `roles` (text[] – admin, operator, viewer)
- `mfa_secret` (opcional)
- `created_at`, `last_login_at`

#### `audit_log`
- `id` (bigserial)
- `actor_id` (FK user)
- `action` (enum: create_suite, update_suite, trigger_run, approve_retry, etc.)
- `target_type`, `target_id`
- `metadata` (jsonb)
- `ip_address`
- `user_agent`
- `created_at`

### 5.3 Índices e Considerações

- Índices compostos para `flow_run(status, priority, queued_at)` para dashboards.
- Índice `GIN` em campos `jsonb` usados em filtros (ex.: `result_summary`, `tags`).
- Particionamento opcional de `step_log` por mês para retenção controlada.
- Uso de migrations (TypeORM) + seeds iniciais (roles padrão, usuários admin).

---

## 6. Fila de Execução e Orquestração

1. **Tecnologia sugerida**: BullMQ (Node + Redis), integrando com `@nestjs/bull`.
2. **Produtores**:
   - `ExecutionService.enqueueRun()` cria registro em `flow_run`, insere job na fila (`queue.add('run', payload, options)`).
   - `RetryService.enqueueRetry()` reaproveita snapshot anterior e injeta job com contexto específico.
3. **Consumidores (workers)**:
   - `FlowWorker` recebe job, abre transação unitária ou uso de `FlowRunTransaction`.
   - Sequência: carregar versão + contexto → executar steps → persistir `step_run`/`variable_snapshot` após cada step.
   - Pausar ao encontrar `input` aguardando aprovação, atualizando status `waiting_input` e re-enfileirando quando aprovado.
4. **Durabilidade**: Jobs persistidos no Redis; retentativa automática controlada por `maxAttempts`. Falhas irretratáveis geram eventos `flow_run.status = failed`.
5. **Escalabilidade**: múltiplos workers horizontais; usar locking otimista e transações para evitar corrida.
6. **Monitoramento**: Bull Board ou UI custom para enxergar jobs; expor métricas (jobs ativos, falhas, duração).

---

## 7. Segurança e Prevenção de Injeção

### 7.1 Proteção contra JS malicioso
- **Sandboxing**: usar `vm2` ou process worker isolado para avaliar `{{$js...}}`. Configurar timeout curto e whitelisting explícito de objetos (`faker`, `Math`, utilidades seguras).
- **Feature flags**: permitir desabilitar `{{$js}}` para ambientes sensíveis.
- **Validação estática**: antes de persistir a suite, rodar validadores que rejeitam uso de `require`, `process`, `eval`, etc.
- **Escapes**: todas as strings externas (inputs, env) devem ser tratadas como dados, nunca código.

### 7.2 Segurança API e Dados
- Autenticação via JWT + refresh + integração com SSO quando disponível.
- RBAC granular (admin/operator/viewer) controlando quem pode aprovar retries, editar suites ou executar flows críticos.
- Rate limiting e proteção contra brute-force.
- Logs auditáveis de toda alteração (ver `audit_log`).
- Sanitização de payloads (class-transformer + class-validator).
- Criptografia em repouso (Postgres TDE ou colunas sensíveis com `pgcrypto`).

### 7.3 Segredos e Configurações
- Usar `@nestjs/config` com validação (Joi) para envs obrigatórios (DB, Redis, JWT, secrets externos).
- Segredos (tokens externos) salvos em cofres (Vault, AWS Secrets) e injetados em runtime; nunca persistir plaintext no DB.

---

## 8. APIs e Interatividade

### 8.1 Endpoints REST

| Método | Rota | Descrição |
| --- | --- | --- |
| `POST /flows` | Cria suite (upload YAML e metadados) |
| `POST /flows/:id/versions` | Nova versão |
| `GET /flows/:id/versions/:version` | Busca versão específica |
| `POST /runs` | Dispara execução (payload define suite/version e overrides) |
| `GET /runs/:id` | Status atual + detalhes |
| `GET /runs/:id/steps` | Lista steps com estado/logs |
| `POST /runs/:id/retry` | Retry completo |
| `POST /runs/:id/steps/:stepId/retry` | Retry parcial/manual |
| `POST /runs/:id/inputs` | Submete input pendente |
| `POST /runs/:id/cancel` | Cancela execução |
| `GET /queue/jobs` | Dashboard de jobs ativos/falhos |
| `POST /queue/jobs/:id/retry` | Retry manual via queue |
| `POST /queue/jobs/:id/remove` | Remoção/cleanup |

### 8.2 WebSockets/Event Streaming
- Canal `runs.{id}` emitindo eventos (`step_started`, `step_success`, `step_failed`, `waiting_input`).
- Canal `queue.overview` com contagem agregada.

### 8.3 CLI de Operações
- `nest start run --suite start-flow.yaml --priority high` (CLI chama API com token).
- Scripts para exportar relatórios, listar runs, aprovar retries via linha de comando.

### 8.4 Input dinâmico guiado por respostas

1. **Persistência de contexto completo**: cada `step_run` armazena `response_snapshot`, `assertions` e `captures`. A tabela `variable_snapshot` guarda todos os valores interpolados por step, permitindo reconstruir opções de input com base nos dados retornados pela API (ex.: listas de propostas e estágios).
2. **Pausa controlada na fila**: quando um step define `input` (select, confirm, text), o worker marca o `flow_run.status = waiting_input`, grava um registro em `step_run.status = waiting_input` e estaciona o job no Redis com tag `waiting`. Nenhum dado é perdido porque o estado completo permanece no Postgres.
3. **Geração de opções**: o backend reexecuta os templates de input usando os snapshots persistidos, garantindo que as opções exibidas ao operador/cliente sejam idênticas às calculadas originalmente pelo engine legado (inclusive dependent selects, cálculos JS previamente aprovados, etc.).
4. **Aprovação e retomada**: o endpoint `POST /runs/:id/inputs` grava a decisão (tabela `variable_snapshot` com `source = input`), atualiza o `step_run`, reencaminha um job na fila apontando para o próximo step e registra a ação em `audit_log`.
5. **Automação opcional**: quando o input depender de regras determinísticas (ex.: escolher primeiro item), podemos habilitar policy automática que preenche o input via serviço dedicado antes de retomar o job, preservando flexibilidade.
6. **WebSocket/Notificações**: eventos `waiting_input` e `input_received` são propagados via canal `runs.{id}` para dashboards ou CLI interativa, reproduzindo a experiência atual de tomada de decisão baseada em retornos.

### 8.5 Execução em esteira (CI/CD)

1. **CLI headless**: manter um utilitário `flow-test-cli` que conversa com a API (ou roda em modo stand-alone) para disparar suites como parte de pipelines (`npm run flow:ci -- --suite tests/start-flow.yaml`).
2. **Modo non-interactive**: para inputs, oferecer flags (`--input-policy auto` ou `--input-file`) que alimentam respostas previamente definidas; o backend aceita payload único anexado ao `flow_run.input_payload` garantindo execução determinística na esteira.
3. **API Tokens**: criar `api_token` com escopo restrito (apenas trigger/read) para CI. Tokens são rotacionados e auditados.
4. **Feedback síncrono**: a CLI consulta periodicamente o endpoint `GET /runs/:id` até conclusão. Em caso de `waiting_input` e policy `auto`, a execução continua; caso contrário, o pipeline falha rapidamente com logs claros.
5. **Export de resultados**: o pipeline baixa `result_summary` e anexos (logs, HTML) via endpoints dedicados, permitindo publicação como artefato de build.
6. **Fallback stand-alone**: se a API estiver indisponível, o pacote Nest expose um comando `nest start single-run` que executa em memória usando as mesmas bibliotecas do worker, garantindo que a esteira nunca fica bloqueada.

---

## 9. Adaptação do Engine Atual

1. **Serviços**:
   - `HttpService` → provider Nest injectable reutilizando axios + interceptors.
   - `AssertionService`, `CaptureService`, `VariableService` → providers isolados com interfaces claras.
   - `ExecutionService` atual → quebrar em `FlowRunner` (executa steps) + `ExecutionOrchestrator` (gerencia estado + DB).
2. **Tipos**: migrar `src/types/common.types.ts` para libs compartilhadas (`libs/types`), exportadas para API e worker.
3. **Config**: usar `ConfigModule` para defaults (timeout, base_url fallback, faker locale).
4. **Relatórios**: reusar templates existentes, mas ler dados do Postgres. Implementar repositórios para gerar JSON/HTML.

---

## 10. Processo de Migração – Fases

| Fase | Entregáveis | Observações |
| --- | --- | --- |
| 0. Preparação | Projeto Nest, ConfigModule, TypeORM, BullMQ, lint/test | Automatizar CI e qualidade |
| 1. Persistência Básica | Schemas e migrations iniciais, FlowSuite/Version CRUD | Importar suites existentes |
| 2. Executor Sincrônico | Portar FlowRunner para Nest sem fila, salvar execuções no DB | Garantir paridade funcional |
| 3. Fila & Worker | Integrar BullMQ, dividir API/Worker, suportar retries automáticos | Monitorar carga |
| 4. Interatividade | Inputs pendentes, WebSocket, manual retry workflow | UX mínima via Postman/UI leve |
| 5. Segurança | Sandboxing JS, RBAC completo, auditoria, hardening infra | Testes de penetração |
| 6. Decomissionar legado | Redirecionar CLI/CI para novo sistema, remover engine antigo | Plano de rollback definido |

Critérios de aceite por fase: testes automatizados, migração de dados validada, cobertura de logs.

---

## 11. Operações e Observabilidade

- **Logs**: Winston + transport JSON estruturado; armazenar em `step_log` + stream para ELK/CloudWatch.
- **Métricas**: Prometheus (tempo médio por step, número de retries, falhas). Expor `/metrics`.
- **Tracing**: OpenTelemetry integrando API e worker (trace por `flow_run_id`).
- **Alertas**: thresholds (falhas consecutivas, job travado, backlog de fila).
- **Retenção**: políticas para purgar runs antigos ou arquivar para data lake.

---

## 12. Fluxo de Retry Manual

1. `flow_run` falha → status `failed` + `manual_retry_request` opcional criada automaticamente.
2. Operador avalia logs no painel, inclui `reason` e solicita retry parcial (step alvo) ou total.
3. `RetryService` gera snapshot do contexto (variáveis + dados) a partir de `variable_snapshot` e `step_run`.
4. Novo job na fila com payload `retry_of = original_run_id`. Mantém histórico (linka runs).
5. Atualizar `manual_retry_request.status` para `executed` quando job completar.
6. Todos os eventos registrados em `audit_log`.

---

## 13. Segurança Operacional Adicional

- **Isolamento de Workers**: rodar workers em container separado com user não privilegiado.
- **Atualizações de dependência**: pipeline para checar CVEs (npm audit, Snyk).
- **Backups**: estratégia PITR para Postgres, snapshots de Redis.
- **Pensar em secrets rotativos**: tokens de API com expiração.
- **Testes de fuzzing** para payloads YAML/inputs.

---

## 14. Riscos e Mitigações

| Risco | Impacto | Mitigação |
| --- | --- | --- |
| Execução de JS malicioso | Compromete servidor | Sandbox, validação, limites de recursos |
| Fila congestionada | Atraso em execuções críticas | Escalar workers, monitorar backlog, prioridades |
| Migração de dados inconsistente | Falha em execuções históricas | Scripts de verificação, dry-run, validação de checksums |
| Falta de visibilidade | Operação às cegas | Observabilidade desde o início |
| Erros de schema | Falha no deploy | Migrations versionadas + testes de integração |

---

## 15. Checklist de Implementação

### Infraestrutura
- [ ] Configurar Postgres com roles dedicadas e SSL.
- [ ] Provisionar Redis para filas.
- [ ] Definir pipelines CI/CD com lint, test, e2e.

### Código
- [ ] Criar módulos listados (Auth, Flow, Execution, Worker, Persistence, Observability).
- [ ] Implementar entidades e migrations no TypeORM.
- [ ] Portar serviços (HTTP, Assertion, Variable, Capture) para providers Nest.
- [ ] Implementar sandbox seguro para `{{$js}}`.

### Dados e Operações
- [ ] Definir processo de importação dos YAML existentes.
- [ ] Criar dashboards (Queue, Runs, Audits).
- [ ] Implementar fluxo de retry manual fim a fim.
- [ ] Escrita de documentação operacional (runbooks, SOPs).

---

## 16. Próximos Passos

1. Validar este plano com todas as partes (engenharia, QA, segurança, produto).
2. Priorizar backlog (fases 0 e 1) e criar épicos técnicos.
3. Configurar repositório Nest com estrutura de módulos sugerida.
4. Iniciar desenvolvimento incremental, garantindo testes automatizados por módulo.
5. Preparar ambiente staging para testes integrados antes de migrar produção.

---

> **Resumo**: migrar para NestJS + PostgreSQL permite execução em fila, histórico completo, segurança forte e escalabilidade. O plano acima cobre arquitetura, entidades, processos e controles necessários para entregar essa evolução de forma segura e incremental.
