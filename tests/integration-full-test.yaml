# Teste Integrado Completo - Todas as Funcionalidades
suite_name: "Teste Integrado Completo do Flow Test Engine"
node_id: "integration_full"
description: "Combina todas as funcionalidades: imports, scenarios, captures, assertions, faker e interpolação"

base_url: "{{httpbin_url}}"

# Configuração Faker
faker:
  locale: "pt_BR"
  seed: 2024


# Variáveis globais
variables:
  integration_test_id: "INTEG_001"
  test_start_time: "2024-01-01T15:00:00Z"
  max_response_time: 2000
  success_threshold: 0.95

  # Mock auth variables
  access_token: "mock_token_123456789"
  user_profile: "{'id': '12345', 'name': 'Mock User', 'email': 'mock@example.com'}"
  token_valid: true
  auth_timestamp: "2024-01-01T12:00:00Z"

  # Mock setup variables
  session_id: "mock_session_987654321"
  environment: "integration"
  api_version: "v3.0"
  setup_validated: true

exports:
  - e2e_test_summary
  - performance_metrics
  - user_journey_data
  - final_validation_result

steps:
  # Etapa 1: Initialização com dados faker e variáveis importadas
  - name: "Initialize E2E Test with Mixed Data Sources"
    request:
      method: POST
      url: "/post"
      headers:
        Content-Type: "application/json"
        Authorization: "Bearer {{access_token}}"
        X-Session-ID: "{{session_id}}"
        X-Test-ID: "{{integration_test_id}}"
        X-Environment: "{{environment}}"
      body:
        test_initialization:
          # Dados dos flows importados
          authentication:
            token: "{{access_token}}"
            user_profile: "{{user_profile}}"
            session: "{{session_id}}"

          # Dados faker dinâmicos
          test_user:
            id: "{{faker.string.uuid}}"
            name: "{{faker.person.fullName}}"
            email: "{{faker.internet.email}}"
            phone: "{{faker.phone.number}}"
            company: "{{faker.company.name}}"

          # Dados estáticos
          test_metadata:
            test_id: "{{integration_test_id}}"
            start_time: "{{test_start_time}}"
            environment: "{{environment}}"
            api_version: "{{api_version}}"

    # Scenarios para validação inicial
    scenarios:
      # Happy Path: Inicialização bem-sucedida
      - condition: "status_code == `200` && body.json.test_initialization.authentication.token != null"
        then:
          assert:
            status_code: 200
            body:
              json.test_initialization.test_metadata.test_id:
                equals: "INTEG_001"
          capture:
            init_success: "`true`"
            test_user_id: "body.json.test_initialization.test_user.id"
            test_user_email: "body.json.test_initialization.test_user.email"

      # Sad Path: Falha na inicialização
      - condition: "status_code != `200`"
        then:
          capture:
            init_success: "`false`"
            error_reason: "'initialization_failed'"

    continue_on_failure: true

  # Etapa 2: Operações CRUD com Scenarios Condicionais
  - name: "CRUD Operations with Conditional Logic"
    request:
      method: POST
      url: "/post"
      headers:
        Content-Type: "application/json"
        Authorization: "Bearer {{access_token}}"
      body:
        crud_operations:
          # Create operation com faker
          create:
            user_id: "{{test_user_id}}"
            profile:
              name: "{{faker.person.fullName}}"
              department: "{{faker.person.jobArea}}"
              salary: "{{faker.finance.amount}}"
              address:
                street: "{{faker.location.streetAddress}}"
                city: "{{faker.location.city}}"
                country: "{{faker.location.country}}"

          # Update operation com interpolação
          update:
            user_id: "{{test_user_id}}"
            email: "{{test_user_email}}"
            last_modified: "{{faker.date.recent}}"

          # Metadata com todas as fontes
          metadata:
            session_id: "{{session_id}}"
            auth_timestamp: "{{auth_timestamp}}"
            test_id: "{{integration_test_id}}"

    scenarios:
      # Happy Path: CRUD bem-sucedido
      - condition: "status_code == `200` && duration_ms < `{{max_response_time}}`"
        then:
          assert:
            status_code: 200
            response_time_ms:
              less_than: "{{max_response_time}}"
          capture:
            crud_success: "`true`"
            crud_performance: "'excellent'"
            crud_duration: "duration_ms"

      # Performance Warning: Lento mas funcional
      - condition: "status_code == `200` && duration_ms >= `{{max_response_time}}`"
        then:
          capture:
            crud_success: "`true`"
            crud_performance: "'slow'"
            crud_duration: "duration_ms"

      # Sad Path: Falha na operação
      - condition: "status_code != `200`"
        then:
          capture:
            crud_success: "`false`"
            crud_performance: "'failed'"
            error_code: "status_code"

  # Etapa 3: Processamento de Arrays e Dados Complexos
  - name: "Complex Data Processing"
    request:
      method: POST
      url: "/post"
      headers:
        Content-Type: "application/json"
      body:
        data_processing:
          # Array de usuários gerados com faker
          users:
            - id: "{{faker.string.uuid}}"
              name: "{{faker.person.fullName}}"
              email: "{{faker.internet.email}}"
              active: "{{faker.datatype.boolean}}"
            - id: "{{faker.string.uuid}}"
              name: "{{faker.person.fullName}}"
              email: "{{faker.internet.email}}"
              active: "{{faker.datatype.boolean}}"
            - id: "{{faker.string.uuid}}"
              name: "{{faker.person.fullName}}"
              email: "{{faker.internet.email}}"
              active: "{{faker.datatype.boolean}}"

          # Dados financeiros
          transactions:
            - id: "{{faker.string.uuid}}"
              amount: "{{faker.finance.amount}}"
              currency: "{{faker.finance.currencyCode}}"
              date: "{{faker.date.recent}}"
            - id: "{{faker.string.uuid}}"
              amount: "{{faker.finance.amount}}"
              currency: "{{faker.finance.currencyCode}}"
              date: "{{faker.date.recent}}"

          # Contexto do teste
          test_context:
            user_id: "{{test_user_id}}"
            environment: "{{environment}}"
            session: "{{session_id}}"

    assert:
      status_code: 200
      body:
        json.data_processing.test_context.user_id:
          equals: "{{test_user_id}}"

    capture:
      # Captures complexos com JMESPath
      active_users: "body.json.data_processing.users[?active == `true`]"
      user_emails: "body.json.data_processing.users[*].email"
      total_users: "length(body.json.data_processing.users)"
      transaction_count: "length(body.json.data_processing.transactions)"
      # total_amount: "sum(body.json.data_processing.transactions[*].amount)"  # Função sum() falhando - valores não são numéricos

  # Etapa 4: Validação de Performance com Delay
  - name: "Performance Validation with Delay"
    request:
      method: GET
      url: "/delay/1"  # 1 segundo de delay
      headers:
        Authorization: "Bearer {{access_token}}"

    scenarios:
      # Performance excelente (não deveria acontecer com delay de 1s)
      - condition: "duration_ms < `500`"
        then:
          capture:
            performance_rating: "'excellent'"
            performance_score: "`100`"

      # Performance boa (entre 500ms e 1.5s)
      - condition: "duration_ms >= `500` && duration_ms < `1500`"
        then:
          capture:
            performance_rating: "'good'"
            performance_score: "`80`"

      # Performance aceitável (entre 1.5s e 2.5s)
      - condition: "duration_ms >= `1500` && duration_ms < `2500`"
        then:
          capture:
            performance_rating: "'acceptable'"
            performance_score: "`60`"

      # Performance ruim (mais de 2.5s)
      - condition: "duration_ms >= `2500`"
        then:
          capture:
            performance_rating: "'poor'"
            performance_score: "`20`"

    continue_on_failure: true

  # Etapa 5: Aggregação e Validação Final
  - name: "Final Aggregation and Validation"
    request:
      method: POST
      url: "/post"
      headers:
        Content-Type: "application/json"
        Authorization: "Bearer {{access_token}}"
        X-Final-Step: "true"
      body:
        final_validation:
          # Resumo dos flows importados
          imported_flows:
            auth:
              token_present: "{{access_token != null}}"
              user_authenticated: "{{token_valid}}"
            setup:
              environment: "{{environment}}"
              session_active: "{{setup_validated}}"

          # Resumo dos dados gerados
          generated_data:
            test_user: "{{test_user_id}}"
            total_users_processed: "{{total_users}}"
            total_transactions: "{{transaction_count}}"
            active_user_count: "length({{active_users}})"

          # Métricas de performance
          performance:
            crud_success: "{{crud_success}}"
            crud_performance: "{{crud_performance}}"
            performance_rating: "{{performance_rating}}"
            performance_score: "{{performance_score}}"

          # Status geral do teste
          test_summary:
            test_id: "{{integration_test_id}}"
            initialization: "{{init_success}}"
            all_steps_completed: true
            environment: "{{environment}}"

    scenarios:
      # Teste completamente bem-sucedido
      - condition: "body.json.final_validation.test_summary.initialization == `true` && body.json.final_validation.performance.crud_success == `true`"
        then:
          assert:
            status_code: 200
            body:
              json.final_validation.test_summary.all_steps_completed:
                equals: true
          capture:
            final_validation_result: "'all_tests_passed'"
            success_rate: "`100`"
            recommendation: "'ready_for_production'"

      # Teste com warnings
      - condition: "body.json.final_validation.test_summary.initialization == `true` && body.json.final_validation.performance.crud_success == `true` && body.json.final_validation.performance.performance_rating == 'acceptable'"
        then:
          capture:
            final_validation_result: "'tests_passed_with_warnings'"
            success_rate: "`85`"
            recommendation: "'review_performance_before_production'"

      # Teste com falhas
      - condition: "body.json.final_validation.test_summary.initialization == `false` || body.json.final_validation.performance.crud_success == `false`"
        then:
          capture:
            final_validation_result: "'tests_failed'"
            success_rate: "`30`"
            recommendation: "'fix_critical_issues_before_retry'"

    capture:
      e2e_test_summary: "body.json.final_validation"
      performance_metrics: "body.json.final_validation.performance"
      user_journey_data: "body.json.final_validation.generated_data"
      test_completion_time: "'2024-01-01T15:30:00Z'"

  # Etapa 6: Cleanup e Relatório Final
  - name: "Cleanup and Final Report"
    request:
      method: DELETE
      url: "/delete"
      headers:
        Authorization: "Bearer {{access_token}}"
        X-Test-ID: "{{integration_test_id}}"
        X-User-ID: "{{test_user_id}}"

    assert:
      status_code: 200

    capture:
      cleanup_completed: "`true`"
      test_end_time: "'2024-01-01T15:35:00Z'"
      # final_status: "{{final_validation_result}}"  # Interpolação não funciona em capture