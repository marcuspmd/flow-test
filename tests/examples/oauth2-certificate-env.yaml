suite_name: "OAuth2 Token with Client Certificate and Environment Variables"
node_id: "oauth2-cert-env-example"
description: |
  Exemplo completo de autenticação OAuth2 usando:
  - Certificado PEM com senha
  - Basic Authentication
  - Variáveis de ambiente do .env
  - Captura e reutilização de token

# URL base carregada do .env (FLOW_TEST_TOKEN_BASE_URL)
base_url: "{{$env.TOKEN_BASE_URL}}"

# Variáveis locais da suite usando valores do .env
variables:
  # Credenciais OAuth2 Basic Auth
  username: "{{$env.OAUTH_USERNAME}}"      # FLOW_TEST_OAUTH_USERNAME
  password: "{{$env.OAUTH_PASSWORD}}"      # FLOW_TEST_OAUTH_PASSWORD

  # Caminho do certificado
  # ⚠️ IMPORTANTE: Caminhos relativos são resolvidos a partir do diretório onde você EXECUTA o comando (process.cwd())
  # Recomendação: Use variável de ambiente com caminho absoluto
  cert_path: "./certs/client-certificate.pem"  # Relativo ao diretório de execução
  cert_password: "{{$env.PEM_PASSWORD}}"   # FLOW_TEST_PEM_PASSWORD

  # Grant type para OAuth2
  grant_type: "client_credentials"

# Exportar token para uso em outras suites
exports:
  - "access_token"
  - "token_type"
  - "expires_in"
  - "refresh_token"

# Configuração do certificado no nível da suite
# Aplica a todos os requests desta suite
certificate:
  cert_path: "{{cert_path}}"
  passphrase: "{{cert_password}}"
  # Desabilitar verificação SSL (equivalente ao PHP 'verify' => false)
  # ⚠️ USE COM CUIDADO - Apenas para desenvolvimento/testes
  verify: false
  # Se tiver certificado CA separado:
  # ca_path: "./certs/ca-certificate.crt"

metadata:
  priority: "critical"
  tags: ["auth", "oauth2", "certificate", "mTLS"]
  timeout: 30000
  estimated_duration_ms: 5000
  description: "Autenticação OAuth2 com certificado digital e Basic Auth"

steps:
  # ===========================================
  # Step 1: Obter Token OAuth2
  # ===========================================
  - name: "Request OAuth2 Token"
    step_id: "get-token"

    request:
      method: POST
      url: "/token"

      # Query parameters (equivalente ao Guzzle)
      params:
        grant_type: "{{grant_type}}"

      # Headers
      headers:
        # Basic Auth: base64(username:password)
        # Usando JavaScript inline para encode
        Authorization: "Basic {{$js:Buffer.from('{{username}}:{{password}}').toString('base64')}}"
        Accept: "*/*"
        Content-Type: "application/x-www-form-urlencoded"

      # Body form-urlencoded
      body: "grant_type={{grant_type}}"

      # Timeout específico para este request
      timeout: 10000

    # Validações da resposta
    assert:
      # Verificar status code
      status_code: 200

      # Validar tempo de resposta (SLA)
      response_time_ms:
        less_than: 5000
        greater_than: 0

      # Validar estrutura do body
      body:
        # Token de acesso
        access_token:
          exists: true
          type: "string"
          notEmpty: true
          minLength: 10

        # Tipo do token
        token_type:
          exists: true
          type: "string"
          equals: "Bearer"

        # Tempo de expiração
        expires_in:
          exists: true
          type: "number"
          greater_than: 0
          less_than: 86400  # Máximo 24 horas

        # Refresh token (opcional)
        refresh_token:
          type: "string"

    # Capturar dados do token para uso posterior
    capture:
      access_token: "body.access_token"
      token_type: "body.token_type"
      expires_in: "body.expires_in"
      refresh_token: "body.refresh_token"

      # Capturar timestamp para calcular expiração
      token_received_at: "{{$js:Date.now()}}"

      # Capturar resposta completa para debug
      full_token_response: "@"

    metadata:
      description: "Autentica usando client_credentials + certificado PEM + Basic Auth"
      retry:
        max_attempts: 3
        delay_ms: 2000

  # ===========================================
  # Step 2: Validar Token Obtido
  # ===========================================
  - name: "Validate Token"
    step_id: "validate-token"

    request:
      method: GET
      url: "/validate"
      headers:
        # Usar token capturado no step anterior
        Authorization: "{{token_type}} {{access_token}}"
        Accept: "application/json"

    assert:
      status_code: 200
      body:
        valid: {equals: true}
        # Validar que o token pertence ao cliente correto
        client_id: {equals: "{{username}}"}
        expires_in:
          type: "number"
          greater_than: 0

    capture:
      token_valid: "body.valid"
      token_expires_at: "body.expires_at"

    # Continuar mesmo se validação falhar (não crítico)
    continue_on_failure: true

    metadata:
      description: "Valida o token obtido"
      tags: ["validation"]

  # ===========================================
  # Step 3: Exemplo de Uso do Token
  # ===========================================
  - name: "Call Protected API"
    step_id: "test-protected-api"

    # Este step pode ter um certificate diferente se necessário
    # (sobrescreve o da suite)
    # certificate:
    #   pfx_path: "./certs/another-cert.pfx"
    #   passphrase: "{{$env.ANOTHER_CERT_PASSWORD}}"

    request:
      method: GET
      url: "{{$env.API_BASE_URL}}/api/protected-resource"
      headers:
        Authorization: "Bearer {{access_token}}"
        Content-Type: "application/json"
        X-Client-Id: "{{username}}"

    assert:
      status_code: 200
      body:
        success: {equals: true}
        data: {exists: true}

    # Cenários condicionais
    scenarios:
      - name: "Token válido e autorizado"
        condition: "status == `200`"
        then:
          capture:
            api_response_data: "body.data"
          variables:
            api_accessible: true

      - name: "Token expirado"
        condition: "status == `401`"
        then:
          variables:
            need_refresh: true
          # Poderia chamar step de refresh aqui

    metadata:
      description: "Testa acesso a recurso protegido usando o token"
      tags: ["integration"]

  # ===========================================
  # Step 4: Refresh Token (Opcional)
  # ===========================================
  - name: "Refresh Token if Needed"
    step_id: "refresh-token"

    # Só executar se token expirou
    metadata:
      skip: "!{{need_refresh}}"

    request:
      method: POST
      url: "/token"
      params:
        grant_type: "refresh_token"
        refresh_token: "{{refresh_token}}"
      headers:
        Authorization: "Basic {{$js:Buffer.from('{{username}}:{{password}}').toString('base64')}}"
        Content-Type: "application/x-www-form-urlencoded"

    assert:
      status_code: 200
      body:
        access_token: {exists: true}

    capture:
      access_token: "body.access_token"
      token_type: "body.token_type"

    continue_on_failure: true
