# Complete Authentication Flow Example
# Demonstrates full auth lifecycle including token refresh
# Perfect for: Testing auth systems, session management, security

suite_name: "Complete Authentication Flow"
node_id: "auth-flow-complete"
description: "Full authentication lifecycle with registration, login, refresh, and logout"

base_url: "https://httpbin.org"

metadata:
  priority: "critical"
  tags: ["intermediate", "auth", "security"]

variables:
  # Use Faker for unique test users
  test_email: "{{$faker.internet.email}}"
  test_username: "{{$faker.internet.userName}}"
  test_password: "Test@{{$faker.string.alphanumeric({ length: 8 })}}"
  test_name: "{{$faker.person.fullName}}"

# Export tokens for other test suites
exports:
  - auth_token
  - refresh_token
  - user_id

steps:
  # ==================== REGISTRATION ====================
  
  - name: "Register new user account"
    metadata:
      description: "Create a new user account"
      tags: ["registration"]
      priority: "critical"
    
    request:
      method: "POST"
      url: "/post"  # Mock - real: /api/auth/register
      headers:
        Content-Type: "application/json"
        Accept: "application/json"
      body:
        email: "{{test_email}}"
        username: "{{test_username}}"
        password: "{{test_password}}"
        name: "{{test_name}}"
        terms_accepted: true

    assert:
      status_code: 200  # Real API: 201
      # In real API:
      # body:
      #   id: { type: "number", greater_than: 0 }
      #   email: { equals: "{{test_email}}" }
      #   username: { equals: "{{test_username}}" }
      #   created_at: { type: "string" }

    capture:
      # In real API, these would come from the response body
      # For demonstration purposes, using generated values
      user_id: "12345"  # body.id
      registration_success: true

  # ==================== LOGIN ====================
  
  - name: "Login with credentials"
    metadata:
      description: "Authenticate and receive access token"
      tags: ["login"]
      priority: "critical"
    
    request:
      method: "POST"
      url: "/post"  # Mock - real: /api/auth/login
      headers:
        Content-Type: "application/json"
      body:
        email: "{{test_email}}"
        password: "{{test_password}}"

    assert:
      status_code: 200
      # Real API assertions:
      # body:
      #   access_token:
      #     type: "string"
      #     notEmpty: true
      #     minLength: 20
      #   refresh_token:
      #     type: "string"
      #     notEmpty: true
      #   token_type: { equals: "Bearer" }
      #   expires_in: { type: "number" }
      #   user:
      #     id: { equals: "{{user_id}}" }
      #     email: { equals: "{{test_email}}" }

    capture:
      # In real API, these would come from the login response
      # For demonstration purposes only - DO NOT use in production
      auth_token: "mock_access_token_abc123xyz789"
      refresh_token: "mock_refresh_token_def456uvw012"
      token_expires_in: 3600

  # ==================== VERIFY TOKEN ====================
  
  - name: "Verify access token works"
    metadata:
      description: "Test token by accessing protected endpoint"
      tags: ["verification"]
    
    request:
      method: "GET"
      url: "/get"  # Mock - real: /api/auth/me
      headers:
        Authorization: "Bearer {{auth_token}}"
        Accept: "application/json"

    assert:
      status_code: 200
      # Real API would return user info:
      # body:
      #   id: { equals: "{{user_id}}" }
      #   email: { equals: "{{test_email}}" }
      #   username: { equals: "{{test_username}}" }

  # ==================== PROTECTED RESOURCES ====================
  
  - name: "Access protected resource - user profile"
    metadata:
      description: "Access user's own profile"
      tags: ["protected"]
    
    request:
      method: "GET"
      url: "/get?user_id={{user_id}}"  # Mock - real: /api/users/{{user_id}}
      headers:
        Authorization: "Bearer {{auth_token}}"

    assert:
      status_code: 200

  - name: "Update user profile"
    metadata:
      description: "Modify user data with authentication"
      tags: ["protected"]
    
    request:
      method: "PUT"
      url: "/put"  # Mock - real: /api/users/{{user_id}}
      headers:
        Authorization: "Bearer {{auth_token}}"
        Content-Type: "application/json"
      body:
        name: "{{$faker.person.fullName}}"
        bio: "Updated bio"

    assert:
      status_code: 200

  # ==================== ERROR CASES ====================
  
  - name: "Test invalid credentials"
    metadata:
      description: "Verify login fails with wrong password"
      tags: ["error-handling", "security"]
    
    request:
      method: "POST"
      url: "/post"  # Mock - real: /api/auth/login
      body:
        email: "{{test_email}}"
        password: "wrong_password"

    assert:
      # Real API would return 401
      status_code: 200  # httpbin always 200
      # In real API:
      # status_code: 401
      # body:
      #   error:
      #     code: { equals: "INVALID_CREDENTIALS" }
      #     message: { contains: "Invalid" }

    continue_on_failure: true

  - name: "Test access without token"
    metadata:
      description: "Verify protected route requires authentication"
      tags: ["error-handling", "security"]
    
    request:
      method: "GET"
      url: "/status/401"  # Mock 401 response

    assert:
      status_code: 401

    continue_on_failure: true

  - name: "Test with expired/invalid token"
    metadata:
      description: "Verify expired tokens are rejected"
      tags: ["error-handling", "security"]
    
    request:
      method: "GET"
      url: "/status/401"
      headers:
        Authorization: "Bearer invalid_token_12345"

    assert:
      status_code: 401
      # Real API:
      # body:
      #   error:
      #     code: { equals: "TOKEN_EXPIRED" }

    continue_on_failure: true

  # ==================== TOKEN REFRESH ====================
  
  - name: "Refresh access token"
    metadata:
      description: "Get new access token using refresh token"
      tags: ["refresh"]
    
    request:
      method: "POST"
      url: "/post"  # Mock - real: /api/auth/refresh
      headers:
        Content-Type: "application/json"
      body:
        refresh_token: "{{refresh_token}}"

    assert:
      status_code: 200
      # Real API:
      # body:
      #   access_token:
      #     type: "string"
      #     notEmpty: true
      #   token_type: { equals: "Bearer" }
      #   expires_in: { type: "number" }

    capture:
      # Update with new token from response
      # For demonstration - in real API: body.access_token
      auth_token: "mock_refreshed_token_ghi789abc456"

  - name: "Verify new token works"
    metadata:
      description: "Confirm refreshed token is valid"
    
    request:
      method: "GET"
      url: "/get"
      headers:
        Authorization: "Bearer {{auth_token}}"

    assert:
      status_code: 200

  # ==================== LOGOUT ====================
  
  - name: "Logout and invalidate tokens"
    metadata:
      description: "End session and revoke tokens"
      tags: ["logout"]
    
    request:
      method: "POST"
      url: "/post"  # Mock - real: /api/auth/logout
      headers:
        Authorization: "Bearer {{auth_token}}"

    assert:
      status_code: 200
      # Real API:
      # body:
      #   message: { contains: "success" }

  - name: "Verify token is invalidated after logout"
    metadata:
      description: "Confirm logged out token doesn't work"
      tags: ["verification"]
    
    request:
      method: "GET"
      url: "/status/401"
      headers:
        Authorization: "Bearer {{auth_token}}"

    assert:
      status_code: 401

    continue_on_failure: true

# Authentication Patterns Summary:
# --------------------------------
# 1. Registration:
#    POST /auth/register
#    { email, password, ... }
#    Returns: { user, token (optional) }
#
# 2. Login:
#    POST /auth/login
#    { email, password }
#    Returns: { access_token, refresh_token, expires_in }
#
# 3. Token Usage:
#    Authorization: Bearer <access_token>
#    Include in all protected requests
#
# 4. Token Refresh:
#    POST /auth/refresh
#    { refresh_token }
#    Returns: { access_token, expires_in }
#
# 5. Logout:
#    POST /auth/logout
#    Authorization: Bearer <access_token>
#    Server invalidates tokens
#
# Token Types:
# -----------
# - Access Token:  Short-lived (15min - 1hr)
# - Refresh Token: Long-lived (days - weeks)
# - ID Token:      User identity (JWT)
#
# Security Best Practices:
# -----------------------
# 1. Use HTTPS in production
# 2. Store tokens securely (httpOnly cookies or secure storage)
# 3. Validate token expiration
# 4. Implement token refresh before expiry
# 5. Invalidate tokens on logout
# 6. Use strong password requirements
# 7. Implement rate limiting on auth endpoints
# 8. Log authentication events
# 9. Support MFA/2FA
# 10. Use secure session management

# Common Auth Flows:
# -----------------
# JWT (JSON Web Token):
#   - Stateless
#   - Self-contained
#   - Verify signature
#
# OAuth 2.0:
#   - Authorization Code flow
#   - Client Credentials flow
#   - Implicit flow (deprecated)
#
# Session-based:
#   - Cookie with session ID
#   - Server-side session storage
#
# API Key:
#   - X-API-Key header
#   - Simple but less secure

# Testing Checklist:
# -----------------
# ✓ Registration with valid data
# ✓ Login with correct credentials
# ✓ Login with wrong credentials
# ✓ Access protected resources
# ✓ Access without authentication
# ✓ Token expiration handling
# ✓ Token refresh flow
# ✓ Logout and token invalidation
# ✓ Multiple failed login attempts (rate limiting)
# ✓ Password requirements validation
# ✓ Email verification (if applicable)
# ✓ Password reset flow
